-- vim: syntax=moon
-- How much log output can you handle? (ERR, WARN, INFO, DEBUG)
log_level "INFO"

-- by overriding os.execute we get the benefits of the coroutine based execute which
-- can be interrupted
:execute = require 'process'
os.execute = execute
:repl, :cmdline = require('shell') -> getcwd! .. ' spook% '

package.path = "#{package.path};spec/support/?.lua;spec/support/?/init.lua"

-- If the spookfile is reloaded we just ensure we reload
-- the other stuff too.
package.loaded['moonpick'] = nil
package.loaded.lint_config = nil
moonpick = require "moonpick"

-- Require some things that come with spook
colors = require "ansicolors"
fs = require 'fs'

-- notify is a global variable. Let's make it a local
-- as is generally recommended in Lua.
-- Let's add the built-in terminal_notifier.
notify.add 'terminal_notifier'

-- If we find 'notifier' in the path, let's
-- add that notifier also. We fail silently otherwise.
pcall notify.add, 'notifier'

-- spookfile_helpers are included inside the spook binary,
-- when needed they should be made locals as generally
-- recommended for Lua.
{
  :until_success
  :command
  :task_filter
  :notifies
} = require 'spookfile_helpers'

-- we use this for notifications, by filtering out
-- the commands not runnable (because the mapped files
-- aren't present), we don't unnecessarily notify on
-- start / fail / success when nothing can actually
-- happen. For a spec runner, this makes sense.
task_list = task_filter fs.is_present
spec = command "./tools/luajit/bin/luajit spec/support/run_busted.lua"
exec = command "./tools/luajit/bin/luajit run.lua"
shpec = command "shpec", env: {SPOOK: "./tools/luajit/bin/luajit run.lua init.moon"}

lint = (file) ->
  notify.info "LINTING #{file}"
  status, res, err = pcall moonpick.lint_file, file
  if status and res and #res > 0
    output = moonpick.format_inspections res
    io.stdout\write colors("\n[ %{yellow}LINT complaints ]\n%{white}#{output}\n\n")
    error "Lint warning"

  if not status or err
    msg = err or res
    io.stdout\write colors("\n[ %{red}LINT error ]\n%{white}#{file}\n#{msg}\n\n")
    error "Lint error"

  io.stdout\write colors("\n[ %{green}LINT: %{white}All good ]\n\n")

-- Directories to watch for changes, how to map detected changes to
-- files and what to run
watch "lib", "spec", ->
  on_changed "^spec/spec_helper%.moon", (event) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "spec/spec_helper.moon"
          spec, "spec"
        )

  on_changed "^spec/(.*)%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "spec/#{name}.moon"
          spec, "spec/#{name}.moon"
        )

  on_changed "^lib/(.*)/event_loop%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "lib/#{name}/event_loop.moon"
          spec, "spec/event_loop_spec.moon"
        )

  on_changed "^lib/(.*)%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "lib/#{name}.moon"
          spec, "spec/#{name}_spec.moon"
        )

-- shpec integration testing
watch "shpec", ->
  on_changed "^shpec/(.*)%.sh", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          shpec, "shpec/#{name}.sh"
        )

if fs.is_present 'playground'
  watch "playground", ->
    on_changed "^playground/(.*)%.moon", (event, name) ->
      exec "playground/#{name}.moon"

    on_changed "^playground/(.*)%.lua", (event, name) ->
      exec "playground/#{name}.lua"

watch_file 'Spookfile', ->
  on_changed (event) ->
    notify.info "Reloading Spookfile..."
    load_spookfile!

watch_file 'lint_config.lua', ->
  on_changed (event) ->
    notify.info "Reloading Spookfile..."
    load_spookfile!


-- cmdline\cmd "spec_files", " - list all spec files", ->
--   os.execute "find spec -type f -name '*_spec.moon'"

-- this would execute any command in path
-- :concat, :insert = table
-- cmdline\dynamic (c, key, value) ->
--   (...) ->
--     arg = {...}
--     screen = arg[1]
--     args = {key}
--     for idx, item in ipairs arg
--       continue if idx == 1
--       insert args, item
--     os.execute concat(args, ' ')

S = require 'syscall'
on_read S.stdin, repl
