-- vim: syntax=moon
-- How much log output can you handle? (ERR, WARN, INFO, DEBUG)
log_level "INFO"
load_spookfile = load_spookfile

package.loaded['moonscript.cmd.lint'] = nil
moonlint = require("moonscript.cmd.lint").lint_file
package.loaded.lint_config = nil
package.loaded.lint_config = pcall -> loadfile('lint_config')!

colors = require "ansicolors"
fs = require 'fs'

notify = require('notify') ->
  add 'terminal_notifier'
  add 'notifier'

local last_task
until_success = (func) ->
  func = last_task if last_task
  last_task = func
  success, result = pcall func
  return error result unless success
  last_task = nil

command = (cmd) ->
  (file) ->
    cmdline = "#{cmd} #{file}"
    notify.info cmdline
    _, _, status = os.execute cmdline
    assert status == 0, cmdline

-- This is so that one can filter
-- out commands not runnable (like when
-- the mapped file doesn't exist)
task_filter = (filter_func) ->
  (...) ->
    args = {...}
    assert #args > 0 and #args % 2 == 0, "a cmd_filter takes an even number of args larger than zero, got #{#args} args"
    current = -1
    ->
      current += 2
      while args[current+1] and not filter_func(args[current+1])
        log.debug "Skipping #{args[current+1]} since the filter_func function returned false"
        current += 2
      args[current], args[current+1]

notifies = (name, info, list) ->
  run = (func, ...) ->
    success, result = pcall func, ...
    unless success
      notify.fail result, info
      error result
  func, arg = list!
  return unless func
  notify.start name, info
  run func, arg
  run func, arg for func, arg in list
  notify.success name, info

-- we use this for notifications, by filtering out
-- the commands not runnable (because the mapped files
-- aren't present), we don't unnecessarily notify on
-- start / fail / success when nothing can actually
-- happen. For a spec runner, this makes sense.
task_list = task_filter fs.is_present
spec = command "./tools/luajit/bin/luajit spec/support/run_busted.lua"
exec = command "./tools/luajit/bin/luajit run.lua"

lint = (file) ->
  notify.info "LINTING #{file}"
  result, err = moonlint file
  success = if result
    io.stdout\write colors("\n[ %{red}LINT error ]\n%{white}#{result}\n\n")
    false
  elseif err
    io.stdout\write colors("\n[ %{red}LINT error ]\n#%{white}{file}\n#{err}\n\n")
    false
  else
    true
  if success
    io.stdout\write colors("\n[ %{green}LINT: %{white}All good ]\n\n")
  assert success == true, "lint #{file}"

-- Directories to watch for changes, how to map detected changes to
-- files and what to run
watch "lib", "spec", ->
  on_changed "^spec/spec_helper%.moon", (event) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "spec/spec_helper.moon"
          spec, "spec"
        )

  on_changed "^spec/(.*)%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "spec/#{name}.moon"
          spec, "spec/#{name}.moon"
        )

  on_changed "^lib/(.*)/event_loop%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "lib/#{name}/event_loop.moon"
          spec, "spec/event_loop_spec.moon"
        )

  on_changed "^lib/(.*)%.moon", (event, name) ->
    until_success ->
      notifies event.path, event,
        task_list(
          lint, "lib/#{name}.moon"
          spec, "spec/#{name}_spec.moon"
        )

watch "playground", ->
  on_changed "^playground/(.*)%.moon", (event, name) ->
      exec "playground/#{name}.moon"

  on_changed "^playground/(.*)%.lua", (event, name) ->
      exec "playground/#{name}.lua"

watch_file 'Spookfile', ->
  on_changed (event) ->
    notify.info "Reloading Spookfile..."
    load_spookfile!

watch_file 'lint_config.lua', ->
  on_changed (event) ->
    notify.info "Reloading Spookfile..."
    load_spookfile!
